<!DOCTYPE html>
<html lang="ko"
      xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="utf-8">
	<title>Hello OpenCV.js</title>
	<script src="http://code.jquery.com/jquery-latest.min.js"></script>
	<style>
      h1 {
          text-align: center;
          font-size: 80px;
      }

      video {
          position: relative;
          width: 70%;
          height: 100%;
      }

      .stop-button {
          position: absolute;
          font-size: 50px;
          top: 800px;
          right: 200px;
      }
	</style>
</head>
<body>
<!-- 카메라 프레임이 그려질 공간 -->
<h1> 카메라 프레임
	<h1>
		<video id="videoInput" width=320 height=240></video>
		<button class="stop-button">중지</button>
		<img id="image" width=820 height=550 src=""/>
		<div><input class="hiddenButton" type="file" multiple style="display: none" /></div>

		<script type="text/javascript" th:inline="javascript">
			/*<![CDATA[*/
			var exinfo =/*[[${session.exinfo}]]*/;
			/*]]*/
			var set = exinfo.userSet
			var count = exinfo.exCount
			var name = exinfo.exName

			// 중지 버튼
			const stopButton = document.querySelector(".stop-button")
			const previewPlayer = document.querySelector("#videoInput")
			let recorder;
			let recordedChunks = [];
			var videoUrl;
			let exerciseId = new Date().getTime();

			/* 카메라 허용하기 & 스트리밍 시작 */
			let video = document.getElementById("videoInput");
			navigator.mediaDevices.getUserMedia({video: true, audio: false})
				.then(function (stream) {
					video.srcObject = stream;
					startRecording(video.captureStream())
					video.play();
				})
				.catch(function (err) {
				});

			function startRecording(stream) {
				recorder = new MediaRecorder(stream);
				recorder.ondataavailable = (e) => {
					recordedChunks.push(e.data)
				};
				recorder.start();
			}

			let cnt = null;

			function stopRecording() {
				previewPlayer.srcObject.getTracks().forEach(track => track.stop());
			}

			var poserList = new Array();
			var poseObject;
			var serverTime;
			var videoData

			//OpencvJS 로딩 완료시 콜백함수
			function onOpenCvReady() {
				let height = video.height;
				let width = video.width;
				let src = new cv.Mat(height, width, cv.CV_8UC4); // 8 byte 4 channel
				let cap = new cv.VideoCapture(video);

				function processVideo() {
					cap.read(src);
					serverTime = performance.now();
					sendData(src.data); // 서버로 데이터 전송
					setTimeout(processVideo, 3000);
					// insertData();
				}

				// schedule first one.
				setTimeout(processVideo, 3000);
			}

			var sendURL;
			if (name == "체스트 플라이") {
				sendURL = "http://localhost:8080/sendFrame?id=" + exerciseId;
			} else if (name == "시티드 로우") {
				sendURL = "http://localhost:8080/sendFrame2?id=" + exerciseId;
			} else {
				sendURL = "http://localhost:8080/sendFrame3?id=" + exerciseId;
			}

			// 중지 버튼
			function goVideo() {
				var oReq = new XMLHttpRequest();
				oReq.open("POST", url, true);
				oReq.onload = function (oEvent) {
					// Uploaded.
					if (oReq.status == 200) {
						let result = oReq.response;
						location.href = "/" + result;
					} else {
						alert("error" + this.status);
					}
				};
				oReq.send(videoData);
			}

			stopButton.onclick = function () {
				console.log("들어옴")
				recorder.ondataavailable = (e) => {
					recordedChunks.push(e.data)
					videoData = new Blob(recordedChunks, {type: "video/webm"});
					url = "/user/exercies-info?cnt=" + cnt;
					if (poserList != null) {
						var formData = new FormData();
						console.log(poseObject.poseResult)
						console.log(poseObject.aiComment)
						formData.append("file", poseObject.poseResult);
						formData.append("aiComment", poseObject.aiComment);
						$.ajax({
							url        : "/user/pose-bad",
							method     : "POST",
							enctype    : 'multipart/form-data',
							data       : formData,
							processData: false,
							contentType: false,
							success    : function () {
								console.log("성공!!")
								goVideo();
							}
						})
					} else {
						goVideo()
					}
				};
				stopRecording();
			}
			function dataURLtoFile(dataurl) {

				var arr = dataurl.split(','),
					mime = arr[0].match(/:(.*?);/)[1],
					bstr = atob(arr[1]),
					n = bstr.length,
					u8arr = new Uint8Array(n);

				while(n--){
					u8arr[n] = bstr.charCodeAt(n);
				}
				return new File([u8arr], {type:mime});
			}

			function sendData(data) {
				const xhr = new XMLHttpRequest();
				xhr.open('POST', sendURL);
				// data가 아니라 json으로 보낼 때 필요한 헤더
				xhr.setRequestHeader('content-type', 'application/json');
				xhr.responseType = 'json';
				xhr.onload = () => {
					var respOjb = xhr.response;
					image_data = respOjb.result_image;
					var imgsrc = "data:image/webp;base64," + image_data;
					document.getElementById('image').src = imgsrc;
					cnt = respOjb.result_cnt;
					var feedback = respOjb.result_feedback;
					var feedback_dis = respOjb.result_dis;

					if (respOjb.result_feedback_l != null || respOjb.result_feedback_r !== null) {
						var comment
						if (respOjb.result_feedback_l == null) {
							console.log(respOjb.result_feedback_r)
							comment = respOjb.result_feedback_r;
						} else if (respOjb.result_feedback_r == null) {
							console.log(respOjb.result_feedback_l)
							comment = respOjb.result_feedback_l;
						}
						poseObject = new Object()
						poseObject.poseResult = dataURLtoFile(imgsrc)
						poseObject.aiComment = comment
						poserList.push(poseObject)
					}
					console.log(cnt)
					console.log(set * count)
					// 만약 갯수를 채운다면 즉시 중지 된다.
					if (cnt == (set * count)) {
						stopButton.onclick()
						stopRecording();
					}
					//비동기로 가져온 값
				};
				xhr.send(data);
			}

		</script>
		<!-- OpencvJS 라이브러리 가져오기 -->
		<script async src="https://docs.opencv.org/3.4.0/opencv.js" onload="onOpenCvReady()"
		        type="text/javascript"></script>
</body>
</html>